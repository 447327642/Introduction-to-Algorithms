# 算法导论课堂笔记
tags: 算法
---
算法的简介及算法分析
====================
>在程序设计方面，除了性能还要考虑什么问题？
>```
>正确性、简洁、可维护性、成本、稳定性、健壮性、功能性、模块化、可扩展性、安全、用户友好度
>```

算法的运行时间
--------------
 + 已排序的程度
 + 输入规模
    一般把算法的运行时间看作输入数据规模的函数
***************
我们最还关注：

 + 算法运行时间的上限（最坏情况）  
 + 平均时间（每种输入的加权平均值，这里的权值也就是一种输入出现的概率，是不可能确定的，但能假设,通常假设每种输入情况的概率相同）
 + 算法的相对速度（两算法在同一机器上运行）
 + 绝对速度
算法的渐近分析
--------------
> 算法的渐近分析：忽略掉那些依赖于机器的常量；不是去检查实际的运行时间，而是关注运行时间的增长
`渐近运算符`：去掉低阶项和最重要项的常系数
例如：    $$3n^3-90n^2-5n-6046=θ(n^3)$$

---
### 归并排序
伪代码：
```
Merge Sort A[1...n]
    1. if n=1, done
    2. recursively sort
        A[1...⌈n/2⌉] and A[⌈n/2⌉+1...n]
    3、'Merge' 2 sorted lists //把以上这两个已排序序列（A[a.first...a.last]和A[b.first...b.last]）合并成有序序列
    
Key subroutine Merge
    i = a.f;
    j = b.f;
    k = 1;
    while(i <= a.l && j <= b.l)
    {
        if(a[i] < b[j])
            temp[k++] = a[i++];
        else
            temp[k++] = b[j++];
    }
    if(i <= a.l)
        temp[k...(a.l+b.l)] = A[i...a.l];
    else
        temp[k...(a.l+b.l)] = A[j...b.l];
    copy temp[1...(a.l+b.l)] to A[a.f...b.l]
```
首先，这是一个递归程序
归并排序中，合并两个已排序序列的函数的时间复杂度为θ(n)
总的时间复杂度为：
$$T(n) = 2*T(n/2)+θ(n)$$
这里的T(x)用构造递归树的方法分析

<center>
![递归树](http://7xssq8.com2.z0.glb.clouddn.com/%E9%80%92%E5%BD%92%E6%A0%91%E5%88%86%E6%9E%90.png)
递归树</center>

其中树的高度h = lgn，叶子数为n，树中一切之和为cnlgn（c为常数）具体在[任务①课程简介及算法分析](http://study.163.com/plan/planLearn.htm?id=64976#/learn/resVideo?lessonId=85)中从`68:16`到`79:56`讲解了归并排序的时间复杂度的分析（其中就包括了递归算法的时间复杂度的分析`构造递归树`）

总的时间复杂度为：$T(n)=θ(nlgn)$
而插入排序的时间复杂度是$θ(n^2)$，因此在n>30时，$n^2>nlgn$，即归并排序比插入排序要快

学习进度：任务1`结束`

 